### Lastest load into a package.

### Export Namespace does not use .First.lib() and .Last.lib(), but use
### .onLoad() and .onUnload().
# .First.lib <- function(lib, pkg){
# } # End of .First.lib().

# .Last.lib <- function(libpath){
# } # End of .Last.lib().

.onLoad <- function(libname, pkgname){
  ### Shared library needs to be loaded before "pbdMPI.so"
  mpi.type <- "@MPITYPE@"
  mpi.libpath <- "@MPI_LIBPATH@"

  ### Nautilus needs MPT.
  i.lib <- NULL
  if(mpi.type == "OPENMPI" || mpi.type == "MPICH2" || mpi.type == "MPICH" ||
      mpi.type == "MPT"){
    if(mpi.type == "OPENMPI" || mpi.type == "MPT"){
      mpi.libname <- "libmpi"
    } else{
      mpi.libname <- "libmpich"
    }

    libs <- c(list.files(path = mpi.libpath,
                         pattern = paste(mpi.libname, "\\.so.*", sep = ""),
                         full.names = TRUE))
              ### For Mac OS X, but let system takes care of loading problem.
              # list.files(path = mpi.libpath,
              #            pattern = paste(mpi.libname, "\\..*dylib", sep = ""),
              #            full.names = TRUE))
    for(i in 1:length(libs)){
      ret <- try(dyn.load(libs[i]), silent = TRUE)
      if(class(ret) != "try-error"){
        i.lib <- libs[i]
        ### CRAN doesn't allow this anymore. Use "pkg_initialize" instead.
        # assign(".__MPI_LIB__", i.libs, envir = .GlobalEnv)
        break
      }
    }
  }

  library.dynam("pbdMPI", pkgname, libname)

  ### A libmpi*.so is found. For Mac OSX, this should be NULL and skipped
  if(! is.null(i.lib)){
    ### To fool CRAN.
    .Call("pkg_initialize", i.lib, PACKAGE = "pbdMPI")
  }

  # if(! is.loaded("spmd_initialize", PACKAGE = "pbdMPI")){
  #   stop("pbdMPI is not loaded.")
  # }

  # if(! exists(".__DISABLE_MPI_INIT__", envir = .GlobalEnv)){
  #   assign(".__DISABLE_MPI_INIT__", FALSE, envir = .GlobalEnv)
  # }

  .Call("spmd_initialize", PACKAGE = "pbdMPI")
  # .comm.size <- .Call("spmd_comm_size", 0L, PACKAGE = "pbdMPI")
  # .comm.rank <- .Call("spmd_comm_rank", 0L, PACKAGE = "pbdMPI")
  # assign(".comm.size", .comm.size, envir = .GlobalEnv)
  # assign(".comm.rank", .comm.rank, envir = .GlobalEnv)

  # base::set.seed(1234)
  invisible()
} # End of .onLoad().

.onUnload <- function(libpath){
  ### Do not finalize MPI by default, which can cause problem for external API.
  ### Let user take care of shut down business.
  pbdMPI::spmd.finalize(mpi.finalize = FALSE)
  library.dynam.unload("pbdMPI", libpath)

  ### Shared library needs to be unloaded after "pbdMPI.so"
  mpi.type <- "@MPITYPE@"
  mpi.libpath <- "@MPI_LIBPATH@"

  ### Nautilus needs MPT.
  if(mpi.type == "OPENMPI" || mpi.type == "MPICH2" || mpi.type == "MPICH" ||
      mpi.type == "MPT"){
    if(mpi.type == "OPENMPI" || mpi.type == "MPT"){
      mpi.libname <- "libmpi"
    } else{
      mpi.libname <- "libmpich"
    }

    libs <- c(list.files(path = mpi.libpath,
                         pattern = paste(mpi.libname, "\\.so.*", sep = ""),
                         full.names = TRUE))
              ### For Mac OS X, but let system takes care of loading problem.
              # list.files(path = mpi.libpath,
              #            pattern = paste(mpi.libname, "\\..*dylib", sep = ""),
              #            full.names = TRUE))
    for(i.lib in libs){
      ret <- try(dyn.unload(i.lib), silent = TRUE)
    }
  }

  invisible()
} # End of .onUnload().

.onAttach <- function(libname, pkgname){
  if(interactive()){
    pbdR.msg <-
"
    pbdR is mainly designed for batch environment or in SPMD programming.
    Please utilize High Performance Computing Resource or consider an
    allociation via ``http://www.nics.tennessee.edu/getting-an-allocation''
    with XSEDE at ``http://www.xsede.org/overview''.
"
  } else{
    pbdR.msg <-
"
    High Performance Computing Resource is available via
    ``http://www.nics.tennessee.edu/getting-an-allocation''
    with XSEDE at ``http://www.xsede.org/overview''.
"
  }
  if(spmd.comm.rank(0L) == 0){
    packageStartupMessage(pbdR.msg)
  }
  invisible()
} # End of .onAttach().
