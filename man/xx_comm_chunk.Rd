% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/comm.chunk.r
\name{comm.chunk}
\alias{comm.chunk}
\title{comm.chunk}
\usage{
comm.chunk(N, form = "number", type = "balance", lo.side = "left",
  all.rank = FALSE, p = comm.size(), rank = comm.rank())
}
\arguments{
\item{N}{The number of items to split into equal chunks.}

\item{form}{Output a chunk as a sigle "number" or as a "vector" of items from 1:N.}

\item{type}{Either "balance" the chunks so they differ by no more than 1 item or force 
as many as possible to be "equal" with possibly one or more smaller or even
zero size chunks.}

\item{lo.side}{If exact balance is not possible, put the lower chunks on the "left" or on 
the "right".}

\item{all.rank}{FALSE returns only the chunk output for rank r. TRUE returns a vector of 
length p (when form="number"), and a list of length p (when form="vector") 
each containing the output for the corresponding rank.}

\item{p}{The number of chunks (defaults to comm.size()).}

\item{rank}{The rank of returned chunk (defaults to comm.rank()). Note that ranks are 
numbered from 0 to p-1, whereas the list elements for all.rank=TRUE are 
numbered 1 to p.}
}
\value{
A numeric value from 0:N or a vector giving a contiguous subset of 1:N 
(depending on form) for the rank instance. If all.rank is TRUE, a vector 
or a list of vectors, respectively.
}
\description{
Given a total number of items comm.chunk splits the number into equal 
chunks. Warious options are possible when the number does not split evenly
into chunks.
}
\examples{
\dontrun{
## Note that the p and rank parameters are provided by comm.size() and
## comm.rank(), respectively, when running in parallel with pbdMPI and
## need not be specified.
#library(pbdIO)
suppressMessages(library(pbdMPI, quietly = TRUE))
init()

comm.chunk(16, all.rank=TRUE, p=5)
comm.chunk(16, type="equal", all.rank=TRUE, p=5)
comm.chunk(16, type="equal", lo.side="right", all.rank=TRUE, p=5)
comm.chunk(16, p=5, rank=0)

finalize()
}
}

